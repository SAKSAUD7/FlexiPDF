import React, { useState, useRef, useEffect, useCallback } from 'react';
import { useDropzone } from 'react-dropzone';
import * as pdfjsLib from 'pdfjs-dist';
import { PDFDocument, rgb, StandardFonts } from 'pdf-lib';
import * as fabric from 'fabric';
import toast from 'react-hot-toast';
import {
  DocumentArrowUpIcon,
  PencilIcon,
  PaintBrushIcon,
  CursorArrowRippleIcon,
  PhotoIcon,
  RectangleStackIcon,
  ArrowUturnLeftIcon,
  ArrowUturnRightIcon,
  MagnifyingGlassPlusIcon,
  MagnifyingGlassMinusIcon,
  ArrowDownTrayIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
  EyeDropperIcon,
  SparklesIcon,
} from '@heroicons/react/24/outline';

// Set up PDF.js worker
pdfjsLib.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js`;

const tools = {
  SELECT: 'select',
  TEXT: 'text',
  DRAW: 'draw',
  SHAPE: 'shape',
  IMAGE: 'image',
  HIGHLIGHT: 'highlight',
  SIGNATURE: 'signature',
};

const shapeTypes = {
  RECTANGLE: 'rectangle',
  CIRCLE: 'circle',
  LINE: 'line',
  ARROW: 'arrow',
};

export default function EditPdf() {
  // State management
  const [pdfFile, setPdfFile] = useState(null);
  const [pdfDoc, setPdfDoc] = useState(null);
  const [currentPage, setCurrentPage] = useState(1);
  const [totalPages, setTotalPages] = useState(0);
  const [zoom, setZoom] = useState(1);
  const [activeTool, setActiveTool] = useState(tools.SELECT);
  const [activeShape, setActiveShape] = useState(shapeTypes.RECTANGLE);
  const [brushSize, setBrushSize] = useState(3);
  const [brushColor, setBrushColor] = useState('#000000');
  const [textColor, setTextColor] = useState('#000000');
  const [fontSize, setFontSize] = useState(16);
  const [isDrawing, setIsDrawing] = useState(false);
  const [fabricCanvas, setFabricCanvas] = useState(null);
  const [history, setHistory] = useState([]);
  const [historyIndex, setHistoryIndex] = useState(-1);
  const [isLoading, setIsLoading] = useState(false);

  // Refs
  const canvasRef = useRef(null);
  const fabricCanvasRef = useRef(null);
  const fileInputRef = useRef(null);

  // Initialize Fabric.js canvas
  useEffect(() => {
    if (canvasRef.current && !fabricCanvas) {
      const canvas = new fabric.Canvas(canvasRef.current, {
        width: 800,
        height: 1000,
        backgroundColor: 'white',
      });
      
      setFabricCanvas(canvas);
      fabricCanvasRef.current = canvas;

      // Save initial state
      saveToHistory(canvas);

      return () => {
        canvas.dispose();
      };
    }
  }, []);

  // File upload handling
  const onDrop = useCallback(async (acceptedFiles) => {
    const file = acceptedFiles[0];
    if (file && file.type === 'application/pdf') {
      setIsLoading(true);
      try {
        setPdfFile(file);
        await loadPdf(file);
        toast.success('PDF loaded successfully!');
      } catch (error) {
        console.error('Error loading PDF:', error);
        toast.error('Failed to load PDF file');
      } finally {
        setIsLoading(false);
      }
    } else {
      toast.error('Please upload a valid PDF file');
    }
  }, []);

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: {
      'application/pdf': ['.pdf']
    },
    multiple: false
  });

  // Load PDF and render first page
  const loadPdf = async (file) => {
    const arrayBuffer = await file.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
    setPdfDoc(pdf);
    setTotalPages(pdf.numPages);
    setCurrentPage(1);
    await renderPage(pdf, 1);
  };

  // Render PDF page to canvas background
  const renderPage = async (pdf, pageNum) => {
    if (!fabricCanvas) return;

    const page = await pdf.getPage(pageNum);
    const viewport = page.getViewport({ scale: zoom });
    
    // Create a temporary canvas for PDF rendering
    const tempCanvas = document.createElement('canvas');
    const tempContext = tempCanvas.getContext('2d');
    tempCanvas.width = viewport.width;
    tempCanvas.height = viewport.height;

    await page.render({
      canvasContext: tempContext,
      viewport: viewport
    }).promise;

    // Set the PDF page as background image in Fabric.js
    const dataURL = tempCanvas.toDataURL();
    fabric.Image.fromURL(dataURL, (img) => {
      fabricCanvas.setBackgroundImage(img, fabricCanvas.renderAll.bind(fabricCanvas), {
        scaleX: fabricCanvas.width / img.width,
        scaleY: fabricCanvas.height / img.height
      });
      
      // Resize canvas to match PDF page
      fabricCanvas.setDimensions({
        width: viewport.width,
        height: viewport.height
      });
    });
  };

  // History management
  const saveToHistory = (canvas) => {
    const state = JSON.stringify(canvas.toJSON());
    const newHistory = history.slice(0, historyIndex + 1);
    newHistory.push(state);
    setHistory(newHistory);
    setHistoryIndex(newHistory.length - 1);
  };

  const undo = () => {
    if (historyIndex > 0) {
      const prevIndex = historyIndex - 1;
      setHistoryIndex(prevIndex);
      fabricCanvas.loadFromJSON(history[prevIndex], fabricCanvas.renderAll.bind(fabricCanvas));
    }
  };

  const redo = () => {
    if (historyIndex < history.length - 1) {
      const nextIndex = historyIndex + 1;
      setHistoryIndex(nextIndex);
      fabricCanvas.loadFromJSON(history[nextIndex], fabricCanvas.renderAll.bind(fabricCanvas));
    }
  };

  // Tool handlers
  const handleToolChange = (tool) => {
    setActiveTool(tool);
    if (!fabricCanvas) return;

    // Reset canvas interaction modes
    fabricCanvas.isDrawingMode = false;
    fabricCanvas.selection = true;
    fabricCanvas.defaultCursor = 'default';

    switch (tool) {
      case tools.SELECT:
        fabricCanvas.defaultCursor = 'default';
        break;
      case tools.DRAW:
        fabricCanvas.isDrawingMode = true;
        fabricCanvas.freeDrawingBrush.width = brushSize;
        fabricCanvas.freeDrawingBrush.color = brushColor;
        break;
      case tools.TEXT:
        fabricCanvas.defaultCursor = 'crosshair';
        break;
      case tools.SHAPE:
        fabricCanvas.defaultCursor = 'crosshair';
        break;
      case tools.HIGHLIGHT:
        fabricCanvas.defaultCursor = 'crosshair';
        break;
    }
  };

  // Canvas event handlers
  useEffect(() => {
    if (!fabricCanvas) return;

    const handleMouseDown = (options) => {
      if (activeTool === tools.TEXT) {
        const pointer = fabricCanvas.getPointer(options.e);
        addText(pointer.x, pointer.y);
      } else if (activeTool === tools.SHAPE) {
        const pointer = fabricCanvas.getPointer(options.e);
        startDrawingShape(pointer.x, pointer.y);
      } else if (activeTool === tools.HIGHLIGHT) {
        const pointer = fabricCanvas.getPointer(options.e);
        addHighlight(pointer.x, pointer.y);
      }
    };

    const handleObjectModified = () => {
      saveToHistory(fabricCanvas);
    };

    fabricCanvas.on('mouse:down', handleMouseDown);
    fabricCanvas.on('object:modified', handleObjectModified);
    fabricCanvas.on('path:created', handleObjectModified);

    return () => {
      fabricCanvas.off('mouse:down', handleMouseDown);
      fabricCanvas.off('object:modified', handleObjectModified);
      fabricCanvas.off('path:created', handleObjectModified);
    };
  }, [fabricCanvas, activeTool, activeShape, fontSize, textColor, brushColor]);

  // Add text
  const addText = (x, y) => {
    const text = new fabric.IText('Edit this text', {
      left: x,
      top: y,
      fontSize: fontSize,
      fill: textColor,
      fontFamily: 'Arial',
    });
    fabricCanvas.add(text);
    fabricCanvas.setActiveObject(text);
    text.enterEditing();
    saveToHistory(fabricCanvas);
  };

  // Add shapes
  const startDrawingShape = (x, y) => {
    let shape;
    
    switch (activeShape) {
      case shapeTypes.RECTANGLE:
        shape = new fabric.Rect({
          left: x,
          top: y,
          width: 100,
          height: 60,
          fill: 'transparent',
          stroke: brushColor,
          strokeWidth: 2,
        });
        break;
      case shapeTypes.CIRCLE:
        shape = new fabric.Circle({
          left: x,
          top: y,
          radius: 50,
          fill: 'transparent',
          stroke: brushColor,
          strokeWidth: 2,
        });
        break;
      case shapeTypes.LINE:
        shape = new fabric.Line([x, y, x + 100, y], {
          stroke: brushColor,
          strokeWidth: 2,
        });
        break;
      case shapeTypes.ARROW:
        // Create arrow using path
        const arrowPath = `M ${x} ${y} L ${x + 80} ${y} M ${x + 70} ${y - 10} L ${x + 80} ${y} L ${x + 70} ${y + 10}`;
        shape = new fabric.Path(arrowPath, {
          fill: '',
          stroke: brushColor,
          strokeWidth: 2,
        });
        break;
    }
    
    if (shape) {
      fabricCanvas.add(shape);
      saveToHistory(fabricCanvas);
    }
  };

  // Add highlight
  const addHighlight = (x, y) => {
    const highlight = new fabric.Rect({
      left: x,
      top: y,
      width: 100,
      height: 20,
      fill: 'rgba(255, 255, 0, 0.3)',
      stroke: 'rgba(255, 255, 0, 0.8)',
      strokeWidth: 1,
    });
    fabricCanvas.add(highlight);
    saveToHistory(fabricCanvas);
  };

  // Add image
  const handleImageUpload = (event) => {
    const file = event.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        fabric.Image.fromURL(e.target.result, (img) => {
          img.scale(0.5);
          img.set({
            left: 100,
            top: 100,
          });
          fabricCanvas.add(img);
          saveToHistory(fabricCanvas);
        });
      };
      reader.readAsDataURL(file);
    }
  };

  // Zoom controls
  const zoomIn = () => {
    const newZoom = Math.min(zoom * 1.2, 3);
    setZoom(newZoom);
    if (pdfDoc) {
      renderPage(pdfDoc, currentPage);
    }
  };

  const zoomOut = () => {
    const newZoom = Math.max(zoom / 1.2, 0.5);
    setZoom(newZoom);
    if (pdfDoc) {
      renderPage(pdfDoc, currentPage);
    }
  };

  // Page navigation
  const goToPrevPage = async () => {
    if (currentPage > 1) {
      const newPage = currentPage - 1;
      setCurrentPage(newPage);
      await renderPage(pdfDoc, newPage);
    }
  };

  const goToNextPage = async () => {
    if (currentPage < totalPages) {
      const newPage = currentPage + 1;
      setCurrentPage(newPage);
      await renderPage(pdfDoc, newPage);
    }
  };

  // Delete selected object
  const deleteSelected = () => {
    const activeObject = fabricCanvas.getActiveObject();
    if (activeObject) {
      fabricCanvas.remove(activeObject);
      saveToHistory(fabricCanvas);
    }
  };

  // Download edited PDF
  const downloadPdf = async () => {
    if (!pdfFile) {
      toast.error('No PDF file loaded');
      return;
    }

    try {
      setIsLoading(true);
      
      // Get canvas as image
      const canvasDataURL = fabricCanvas.toDataURL({
        format: 'png',
        quality: 1,
        multiplier: 2
      });

      // Create new PDF with edited content
      const existingPdfBytes = await pdfFile.arrayBuffer();
      const pdfDoc = await PDFDocument.load(existingPdfBytes);
      
      // For simplicity, we'll replace the current page with the edited version
      const pages = pdfDoc.getPages();
      const page = pages[currentPage - 1];
      
      // Embed the edited canvas as image
      const pngImage = await pdfDoc.embedPng(canvasDataURL);
      const { width, height } = page.getSize();
      
      page.drawImage(pngImage, {
        x: 0,
        y: 0,
        width: width,
        height: height,
      });

      const pdfBytes = await pdfDoc.save();
      
      // Download the file
      const blob = new Blob([pdfBytes], { type: 'application/pdf' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'edited-pdf.pdf';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      toast.success('PDF downloaded successfully!');
    } catch (error) {
      console.error('Error saving PDF:', error);
      toast.error('Failed to save PDF');
    } finally {
      setIsLoading(false);
    }
  };

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.ctrlKey || e.metaKey) {
        switch (e.key) {
          case 'z':
            e.preventDefault();
            if (e.shiftKey) {
              redo();
            } else {
              undo();
            }
            break;
          case 'y':
            e.preventDefault();
            redo();
            break;
          case 's':
            e.preventDefault();
            downloadPdf();
            break;
        }
      } else if (e.key === 'Delete' || e.key === 'Backspace') {
        deleteSelected();
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [historyIndex, history]);

  const toolbarItems = [
    { tool: tools.SELECT, icon: CursorArrowRippleIcon, label: 'Select' },
    { tool: tools.TEXT, icon: PencilIcon, label: 'Text' },
    { tool: tools.DRAW, icon: PaintBrushIcon, label: 'Draw' },
    { tool: tools.SHAPE, icon: RectangleStackIcon, label: 'Shape' },
    { tool: tools.HIGHLIGHT, icon: EyeDropperIcon, label: 'Highlight' },
    { tool: tools.IMAGE, icon: PhotoIcon, label: 'Image' },
    { tool: tools.SIGNATURE, icon: SparklesIcon, label: 'Signature' },
  ];

  return (
    <div className="min-h-screen bg-gray-50 py-8">
      <div className="mx-auto max-w-7xl px-4 sm:px-6 lg:px-8">
        <div className="mb-8 text-center">
          <h1 className="text-3xl font-bold tracking-tight text-gray-900 sm:text-4xl">
            PDF Editor
          </h1>
          <p className="mt-4 text-lg leading-8 text-gray-600">
            Edit text, add annotations, draw, and modify your PDF documents
          </p>
        </div>

        {!pdfFile ? (
          // File upload area
          <div className="mx-auto max-w-2xl">
            <div
              {...getRootProps()}
              className={`border-2 border-dashed rounded-xl p-12 text-center cursor-pointer transition-colors ${
                isDragActive 
                  ? 'border-blue-400 bg-blue-50' 
                  : 'border-gray-300 hover:border-gray-400'
              }`}
            >
              <input {...getInputProps()} />
              <DocumentArrowUpIcon className="mx-auto h-12 w-12 text-gray-400" />
              <p className="mt-4 text-lg font-medium text-gray-900">
                {isDragActive ? 'Drop your PDF here' : 'Upload PDF to Edit'}
              </p>
              <p className="mt-2 text-sm text-gray-500">
                Drag and drop a PDF file, or click to browse
              </p>
            </div>
          </div>
        ) : (
          // PDF Editor Interface
          <div className="flex gap-6">
            {/* Sidebar */}
            <div className="w-80 bg-white rounded-xl shadow-sm border border-gray-200 p-6 h-fit">
              {/* Tools */}
              <div className="mb-6">
                <h3 className="text-sm font-semibold text-gray-900 mb-3">Tools</h3>
                <div className="grid grid-cols-2 gap-2">
                  {toolbarItems.map(({ tool, icon: Icon, label }) => (
                    <button
                      key={tool}
                      onClick={() => {
                        if (tool === tools.IMAGE) {
                          fileInputRef.current?.click();
                        } else {
                          handleToolChange(tool);
                        }
                      }}
                      className={`flex flex-col items-center p-3 rounded-lg border-2 transition-colors ${
                        activeTool === tool
                          ? 'border-blue-500 bg-blue-50 text-blue-700'
                          : 'border-gray-200 hover:border-gray-300 text-gray-700'
                      }`}
                    >
                      <Icon className="h-5 w-5 mb-1" />
                      <span className="text-xs font-medium">{label}</span>
                    </button>
                  ))}
                </div>
              </div>

              {/* Shape Tools */}
              {activeTool === tools.SHAPE && (
                <div className="mb-6">
                  <h3 className="text-sm font-semibold text-gray-900 mb-3">Shapes</h3>
                  <div className="grid grid-cols-2 gap-2">
                    {Object.entries(shapeTypes).map(([key, shape]) => (
                      <button
                        key={shape}
                        onClick={() => setActiveShape(shape)}
                        className={`p-2 rounded-lg border text-xs font-medium ${
                          activeShape === shape
                            ? 'border-blue-500 bg-blue-50 text-blue-700'
                            : 'border-gray-200 hover:border-gray-300'
                        }`}
                      >
                        {key}
                      </button>
                    ))}
                  </div>
                </div>
              )}

              {/* Drawing Controls */}
              {(activeTool === tools.DRAW || activeTool === tools.SHAPE) && (
                <div className="mb-6">
                  <h3 className="text-sm font-semibold text-gray-900 mb-3">Brush</h3>
                  <div className="space-y-3">
                    <div>
                      <label className="block text-xs font-medium text-gray-700 mb-1">Size</label>
                      <input
                        type="range"
                        min="1"
                        max="20"
                        value={brushSize}
                        onChange={(e) => setBrushSize(parseInt(e.target.value))}
                        className="w-full"
                      />
                      <div className="text-xs text-gray-500 text-center">{brushSize}px</div>
                    </div>
                    <div>
                      <label className="block text-xs font-medium text-gray-700 mb-1">Color</label>
                      <input
                        type="color"
                        value={brushColor}
                        onChange={(e) => setBrushColor(e.target.value)}
                        className="w-full h-8 rounded border"
                      />
                    </div>
                  </div>
                </div>
              )}

              {/* Text Controls */}
              {activeTool === tools.TEXT && (
                <div className="mb-6">
                  <h3 className="text-sm font-semibold text-gray-900 mb-3">Text</h3>
                  <div className="space-y-3">
                    <div>
                      <label className="block text-xs font-medium text-gray-700 mb-1">Size</label>
                      <input
                        type="range"
                        min="8"
                        max="72"
                        value={fontSize}
                        onChange={(e) => setFontSize(parseInt(e.target.value))}
                        className="w-full"
                      />
                      <div className="text-xs text-gray-500 text-center">{fontSize}px</div>
                    </div>
                    <div>
                      <label className="block text-xs font-medium text-gray-700 mb-1">Color</label>
                      <input
                        type="color"
                        value={textColor}
                        onChange={(e) => setTextColor(e.target.value)}
                        className="w-full h-8 rounded border"
                      />
                    </div>
                  </div>
                </div>
              )}

              {/* Actions */}
              <div className="space-y-3">
                <div className="flex gap-2">
                  <button
                    onClick={undo}
                    disabled={historyIndex <= 0}
                    className="flex-1 flex items-center justify-center gap-2 p-2 rounded-lg border border-gray-200 text-sm font-medium text-gray-700 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    <ArrowUturnLeftIcon className="h-4 w-4" />
                    Undo
                  </button>
                  <button
                    onClick={redo}
                    disabled={historyIndex >= history.length - 1}
                    className="flex-1 flex items-center justify-center gap-2 p-2 rounded-lg border border-gray-200 text-sm font-medium text-gray-700 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    <ArrowUturnRightIcon className="h-4 w-4" />
                    Redo
                  </button>
                </div>
                
                <button
                  onClick={deleteSelected}
                  className="w-full p-2 rounded-lg border border-red-200 text-sm font-medium text-red-700 hover:bg-red-50"
                >
                  Delete Selected
                </button>
                
                <button
                  onClick={downloadPdf}
                  disabled={isLoading}
                  className="w-full flex items-center justify-center gap-2 p-3 rounded-lg bg-blue-600 text-white font-medium hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <ArrowDownTrayIcon className="h-4 w-4" />
                  {isLoading ? 'Saving...' : 'Download PDF'}
                </button>
              </div>
            </div>

            {/* Main Canvas Area */}
            <div className="flex-1">
              {/* Top Controls */}
              <div className="bg-white rounded-xl shadow-sm border border-gray-200 p-4 mb-6">
                <div className="flex items-center justify-between">
                  {/* Page Navigation */}
                  <div className="flex items-center gap-4">
                    <button
                      onClick={goToPrevPage}
                      disabled={currentPage <= 1}
                      className="p-2 rounded-lg border border-gray-200 text-gray-700 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      <ChevronLeftIcon className="h-4 w-4" />
                    </button>
                    <span className="text-sm font-medium text-gray-700">
                      Page {currentPage} of {totalPages}
                    </span>
                    <button
                      onClick={goToNextPage}
                      disabled={currentPage >= totalPages}
                      className="p-2 rounded-lg border border-gray-200 text-gray-700 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      <ChevronRightIcon className="h-4 w-4" />
                    </button>
                  </div>

                  {/* Zoom Controls */}
                  <div className="flex items-center gap-2">
                    <button
                      onClick={zoomOut}
                      className="p-2 rounded-lg border border-gray-200 text-gray-700 hover:bg-gray-50"
                    >
                      <MagnifyingGlassMinusIcon className="h-4 w-4" />
                    </button>
                    <span className="text-sm font-medium text-gray-700 min-w-[60px] text-center">
                      {Math.round(zoom * 100)}%
                    </span>
                    <button
                      onClick={zoomIn}
                      className="p-2 rounded-lg border border-gray-200 text-gray-700 hover:bg-gray-50"
                    >
                      <MagnifyingGlassPlusIcon className="h-4 w-4" />
                    </button>
                  </div>
                </div>
              </div>

              {/* Canvas Container */}
              <div className="bg-white rounded-xl shadow-sm border border-gray-200 p-6">
                <div className="overflow-auto max-h-[800px] flex justify-center">
                  <canvas
                    ref={canvasRef}
                    className="border border-gray-300 shadow-lg"
                  />
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Hidden file input for images */}
        <input
          ref={fileInputRef}
          type="file"
          accept="image/*"
          onChange={handleImageUpload}
          className="hidden"
        />
        
        {/* Loading overlay */}
        {isLoading && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white rounded-lg p-6 flex items-center gap-3">
              <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600"></div>
              <span className="font-medium">Processing...</span>
            </div>
          </div>
        )}
      </div>
    </div>
  );
} 